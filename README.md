# HaScene
HaScene is a simple ASCII 3D scene editor with ray tracing renderer written in Haskell.

It consists of two parts: **an ASCII 3D scene editor** and **a ray tracer**. Below are their descriptions.

### ASCII 3D Scene Editor

A scene editor is often an essential tool for 3D photorealistic rendering. It can build a 3D scene, provide a preview of the scene, and finally deliver scene information to a specific renderer to get a photorealistic image. To build a 3D scene, we expect our editor can place, move, rotate, and delete simple 3D models (spheres, cubes, tetrahedrons, etc.), as well as specify the materials of a particular model, the lighting of the scene, and the position of the camera. To preview the scene, we expect our editor can render a simple 3D scene only containing depth information of the model to the terminal using ASCII characters, just like the image below:

![donut](https://github.com/TaKeTube/HaScene/blob/main/donut.gif?raw=true)

(Animation generated by a famous piece of C Code from https://www.a1k0n.net/2006/09/15/obfuscated-c-donut.html)

Scene editing & previewing will be implemented using [the brick library](https://github.com/jtdaugherty/brick/)

### Ray Tracer

A ray tracer is a kind of renderer that render 3D scene using the ray tracing algorithm (which is a recursive algorithm, and we believe it has an affinity with Haskell). It is the cornerstone of modern photorealistic rendering. Considering the amount of work required to implement the scene editor, we plan to use the open-source ray tracer on GitHub and write the interface to the editor. If we have extra time, we will implement the ray tracer ourselves.

**PS:** Two members of our team are familiar with computer graphics, so we think it is not difficult for the team to grasp the principles behind the algorithm. However, since Haskell as a functional programming language is very different from object-oriented programming languages such as C++, we cannot guarantee that the final result of the project will be exactly as described in the proposal.

### API

#### Shape

```haskell
data Point = Point a
	deriving (Show)
makeLenses ''Point

data Surface f =
    Surface
    { 
        _normal :: !(V3 f)
    } deriving (Show)
makeLenses ''Surface

data Triangle f =
    Triangle
    { _triangle_vertices :: {-# UNPACK #-} !(V3 (Point V3 f))
    } deriving (Show)
makeLenses ''Triangle

data Block f =
    Block
    { _block_pos :: !(Point V3 f)
    , _block_edges_len :: !(V3 f)
    } deriving (Show)
makeLenses ''Block

data Sphere f =
    Sphere
    { _sphere_center :: !(Point V3 f)
    , _sphere_radius :: !f
    } deriving (Show)
makeLenses ''Sphere

type Shape2D = Surface | Triangle
type Shape3D = Block | Sphere
```



#### FrontEnd

Input: the config file

```c
0 0 -5              // the init camera position
0 1 -1              // the init light position
3	                // the number of Objects
Sphere 1 2 3 1      // type, args
Block 1 2 3 4 4
Surface 1 2 3
```

Output: `([Shape2D],[Shape3D])`

#### Backend

Input: `([Shape2D],[Shape3D])`

Output: PPM image